name: 'Should Skip Build'
description: 'Check if container build should be skipped based on existing images and file changes'
inputs:
  registry:
    description: 'Container registry URL (e.g., quay.io)'
    required: false
  image:
    description: 'Full image name including namespace (e.g., my-org/my-image)'
    required: false
  commit-sha:
    description: 'Git commit SHA to check'
    required: true
  check-image:
    description: 'Whether to check for existing container images (true/false)'
    required: false
    default: 'true'
  file-patterns:
    description: 'Regex patterns to match files for skip logic (space, comma, or newline-separated)'
    required: false
    default: '\.md$'
outputs:
  should_skip:
    description: 'Whether the build should be skipped (true/false)'
    value: ${{ steps.check.outputs.should_skip }}
  skip_reason:
    description: 'Human-readable reason for skipping'
    value: ${{ steps.check.outputs.skip_reason }}
runs:
  using: 'composite'
  steps:
    - name: Install skopeo
      if: inputs.check-image == 'true'
      shell: bash
      run: |
        if ! command -v skopeo &> /dev/null; then
          echo "Installing skopeo"
          sudo apt-get update -q
          sudo apt-get install -y -q skopeo
        else
          echo "skopeo already installed"
        fi

    - name: Check if build should be skipped
      id: check
      shell: bash
      run: |
        set +e  # Don't exit on error, we handle them explicitly
        
        SHOULD_SKIP="false"
        SKIP_REASON=""
        
        # Check if image exists (if enabled)
        if [ "${{ inputs.check-image }}" = "true" ]; then
          echo "::group::Check if image exists with commit SHA"
          SHORT_SHA=$(echo "${{ inputs.commit-sha }}" | cut -c1-7)
          REPOSITORY="docker://${{ inputs.registry }}/${{ inputs.image }}"
          IMAGE_TAG="${REPOSITORY}:${SHORT_SHA}"
          
          echo "Checking for image: ${IMAGE_TAG}"
          
          # Try to inspect the image - if it exists, skopeo returns 0
          skopeo inspect "${IMAGE_TAG}" &>/dev/null
          IMAGE_EXISTS=$?
          
          if [ $IMAGE_EXISTS -eq 0 ]; then
            SHOULD_SKIP="true"
            SKIP_REASON="Image with commit SHA ${SHORT_SHA} already exists in registry"
            echo "✓ Image exists - build will be skipped"
            echo "should_skip=${SHOULD_SKIP}" >> $GITHUB_OUTPUT
            echo "skip_reason=${SKIP_REASON}" >> $GITHUB_OUTPUT
            echo "::endgroup::"
            exit 0
          else
            echo "✗ Image does not exist - continuing checks"
          fi
          echo "::endgroup::"
        else
          echo "Image checking disabled - skipping image existence check"
        fi
        
        echo "::group::Check if only documentation/ignored files changed"
        
        # Get the list of changed files based on event type
        CHANGED_FILES=""
        
        case "${{ github.event_name }}" in
          workflow_dispatch)
            echo "Workflow triggered manually - skipping file change check"
            echo "should_skip=${SHOULD_SKIP}" >> $GITHUB_OUTPUT
            echo "skip_reason=Manual trigger" >> $GITHUB_OUTPUT
            echo "::endgroup::"
            exit 0
            ;;
            
          pull_request|pull_request_target)
            echo "Pull request event detected"
            if [ -n "${{ github.event.pull_request.base.sha }}" ]; then
              # Find the merge base between PR base and HEAD
              BASE_COMMIT=$(git merge-base ${{ github.event.pull_request.base.sha }} HEAD)
              echo "Base commit (merge-base): $BASE_COMMIT"
              CHANGED_FILES=$(git diff --name-only "$BASE_COMMIT" HEAD)

            else
              echo "Warning: No PR base SHA available, skipping file check"
              echo "should_skip=${SHOULD_SKIP}" >> $GITHUB_OUTPUT
              echo "skip_reason=No base commit available for PR" >> $GITHUB_OUTPUT
              echo "::endgroup::"
              exit 0
            fi
            ;;
            
          push)
            echo "Push event detected"
            if [ -n "${{ github.event.before }}" ] && [ "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]; then
              echo "Comparing with previous commit: ${{ github.event.before }}"
              CHANGED_FILES=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }})
            else
              echo "First push or no previous commit available"
              # Get all files in the current commit
              CHANGED_FILES=$(git diff-tree --name-only -r ${{ github.sha }})
            fi
            ;;
            
          *)
            echo "Unsupported event type: ${{ github.event_name }}"
            echo "Proceeding with build as a safety measure"
            echo "should_skip=${SHOULD_SKIP}" >> $GITHUB_OUTPUT
            echo "skip_reason=Unsupported event type" >> $GITHUB_OUTPUT
            echo "::endgroup::"
            exit 0
            ;;
        esac
        
        if [ -z "$CHANGED_FILES" ]; then
          echo "No files changed - build will be skipped"
          SHOULD_SKIP="true"
          SKIP_REASON="No files changed"
          echo "should_skip=${SHOULD_SKIP}" >> $GITHUB_OUTPUT
          echo "skip_reason=${SKIP_REASON}" >> $GITHUB_OUTPUT
          echo "::endgroup::"
          exit 0
        fi
        
        echo "Changed files:"
        echo "$CHANGED_FILES"
        echo ""
        
        # Parse file patterns (handle space, comma, and newline-separated)
        FILE_PATTERNS="${{ inputs.file-patterns }}"
        FILE_PATTERNS=$(echo "$FILE_PATTERNS" | tr ',\n' ' ')
        
        echo "Checking for file patterns: $FILE_PATTERNS"
        echo ""
        
        # Check if all changed files match the ignore patterns
        ALL_FILES_MATCH_PATTERN="true"
        NON_MATCHING_FILES=()
        
        while IFS= read -r file; do
          if [ -z "$file" ]; then
            continue
          fi
          
          # Check if file matches any of the patterns
          FILE_MATCHES="false"
          for pattern in $FILE_PATTERNS; do
            if [[ "$file" =~ ${pattern} ]]; then
              FILE_MATCHES="true"
              break
            fi
          done
          
          if [ "$FILE_MATCHES" = "false" ]; then
            ALL_FILES_MATCH_PATTERN="false"
            NON_MATCHING_FILES+=("$file")
          fi
        done <<< "$CHANGED_FILES"
        
        if [ "$ALL_FILES_MATCH_PATTERN" = "true" ]; then
          SHOULD_SKIP="true"
          SKIP_REASON="All changed files match skip patterns: $FILE_PATTERNS"
          echo "✓ All changed files match skip patterns - build will be skipped"
        else
          echo "✗ Found ${#NON_MATCHING_FILES[@]} file(s) not matching skip patterns:"
          printf '  - %s\n' "${NON_MATCHING_FILES[@]}"
          echo "Build will proceed"
        fi
        
        echo "::endgroup::"
        
        echo "should_skip=${SHOULD_SKIP}" >> $GITHUB_OUTPUT
        echo "skip_reason=${SKIP_REASON}" >> $GITHUB_OUTPUT

